<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>7-计导导论 | Topology2333&#39;s Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">7-计导导论</span></h1>
<h2 class="author">Topology2333</h2>
<h2 class="date">2022/12/06</h2>
</div>

<main>
<h1 id="这一篇转载-7">这一篇转载 7</h1>
<pre><code>
</code></pre>
<h3 id="提纲">提纲</h3>
<h3 id="递归的概念">递归的概念</h3>
<h3 id="递归过程">递归过程</h3>
<h3 id="递归程序设计">递归程序设计</h3>
<pre><code>
</code></pre>
<h1 id="1递归的概念">1.递归的概念</h1>
<p>原始递归函数在可计算性理论中占有重要地位，是一种算法思想和计算模型。
基于原始递归函数的递归算法是算法设计的有力工具，对于拓展编程思路非常有用。
进行递归算法设计的前提是要建立起递归概念，我们先从一个最简单的例子导入。</p>
<p>例：编写一个函数fac，计算阶乘n!
按过去的迭代算法，该函数可以写成：
int fac(int n)
{
int i, p;
p = 1;
for(i = 2; i &lt;= n; i++)
p = p * i;
return p;
}
现在换一个角度考虑，n！不仅是1×2×3×…×n,
还可以定义成：</p>
<p>递归的定义：
从程序书写来看，在定义一个函数时，若在函数的功能实现部分又出现对它本身的调用，则称该函数是递归的或递归定义的。</p>
<p>从函数动态运行来看，当调用一个函数A时，在进入函数A且还没有退出（返回）之前，又再一次调用A，则称为函数A的递归调用。
递归可以分为直接递归和间接递归两种。
直接递归：函数体里面发生对自己的调用；
间接递归：函数A调用函数B，而函数B又直接或间接地调用函数A。</p>
<p>不用担心函数A内部又调用函数A，会使得调用无休无止，肯定存在某个条件，当该条件成立的时候，函数A将不会再调用自身。</p>
<p>例如，求n！时，该结束条件是 if(n == 0)</p>
<pre><code class="language-c">   int f(int n)
   {
      if (n == 0) 
         return 1;
      else
         return n * f(n-1);
   }
</code></pre>
<h1 id="2递归过程">2.递归过程</h1>
<p>求f（2）的
递归调用过程？</p>
<p>请思考：
发出f(2)调用时，将2赋值给形参n。然后发出f(1)调用，将1赋值给形参n。接着发出f(0)调用，将0赋值给形参n。后来赋给形参n的值会不会覆盖原来赋给n的值（如值1覆盖原来的值2）？为什么？
不会，每一次函数调用会在栈顶分配新的活动记录。
对递归函数的每一次调用结束返回时，为何能回到调用前的程序运行状态？
当f(1)调用结束时，位于栈顶的f(1)的活动记录将出栈，位于栈顶的将是f(2)函数的活动记录。
求f(6)的递归调用过程
可见，递归算法的执行过程分递推和回归两个阶段。当递推时，并没有求值的计算操作，实际的计算操作是在回归过程实现的。
递推阶段：
递推阶段是个不断简化问题的阶段：把对较复杂问题（规模为n）的求解转化为比原问题简单一些的问题（规模小于n）的求解 。例如对f (6)的求解转化为f(5)的求解， 对f(5)的求解转化为f(4)的求解…直到转化为对f(0)的求解。
当递推到最简单的不用再简化的问题时，递推终止。如f函数中，n==0的情况。
回归阶段：
在回归阶段，当获得最简单情况的解后，逐级返回，依次得到稍复杂问题的解 。如在得到f(1)的解后，又依次得到f(2)、f(3)…直到f(6)的值。
思考：递归与迭代的比较(以求阶乘为例)。
迭代:从已知的初始条件出发(自底向上)，逐次去求所需要的阶乘值，这相当于从菜心“推到”（通过循环）最外层的菜叶。
f(0) = 1
f (1) = 1<em>f (0) = 1
f (2) = 2</em>f (1) = 2
递归：先从最外层的菜叶“递推”到菜心(自顶向下,递归函数调用)，再从菜心“回归”到最外面的菜叶（递归函数返回，带值返回）。</p>
<p>递归算法的出发点不放在初始条件上，而放在求解的目标上，是从所求的未知项出发逐次调用本身的求解过程，直到递归的边界（即初始条件）。
就求阶乘而言，读者会认为递归算法可能是多余的，费力而不讨好。但许多实际问题，从初始条件出发不可能或不容易找到显而易见的迭代关系，这时从求解目标出发的递归算法就表现出了明显的优越性。
下面我们将会看到，递归算法比较符合人的思维方式，逻辑性强，可将问题描述得简单扼要，具有良好的可读性，许多看来相当复杂，或难以下手的问题，如果能够使用递归算法就会使问题变得易于处理。</p>
<h1 id="3递归程序设计">3.递归程序设计</h1>
<p>什么样的问题可以用递归解决？
回顾“自顶向下，逐步细化”的程序设计思想。
如果解决问题的方法是把该问题分解成小的子问题，并且这些小的子问题可以用同样的算法解决，这样不断分解，直到子问题比较简单、可以直接解决时分解过程即终止，那么就可以用递归。(分治策略)
递归的思想就是先将一个问题转化为与原问题性质相同、但规模小一级的子问题，然后再重复这样的转化，直到问题的规模减小到我们很容易解决为止。</p>
<p>递归程序设计举例</p>
<p>练习1.求浮点数x的n次幂(n≧0)。函数递归定义:</p>
<p>练习2. 设计递归函数求任意正整数的位数。num=1234</p>
<p>练习3.求任意正整数的逆置数。num=1234
递归思路1：将除最高位之外的数先逆置。
例如： reverse (1234)=reverse(234）×10 + 1</p>
<p>递归设计思路1：num=1234
reverse(1234,4)＝1+ reverse(234,3)*10</p>
<p>reverse(234,3)=2+reverse(34,2)*10</p>
<p>reverse(34,2)=3+reverse(4,1)*10</p>
<p>reverse(4,1)=4</p>
<pre><code class="language-c">int reverse(int num,int len)
{
    int restNum, highBit;

    if (len == 1)          //如果num是个位数则递归结束 
        return num;
    else{
  highBit = num / power(10, len-1);//得到最高位 
  restNum = num % power(10, len-1); //得到剩余位
  //递归调用，并形成逆置数
  return highBit + reverse(restNum, len-1)*10; 
}
}
</code></pre>
<p>练习3. 求任意正整数的逆置数。     num=1234
递归思路2：将除最低位之外的数先逆置。
例如：reverse(1234)=4*1000+reverse(123)</p>
<p>递归设计思路2： num=1234
reverse(1234,4)＝4*1000+ reverse(123,3)</p>
<pre><code>reverse(123,3)=3*100+reverse(12,2)

reverse(12,2)=2*10+reverse(1,1)                               

reverse(1)=1
</code></pre>
<pre><code class="language-c">int reverse(int num,int len)
{
    int restNum;
    int lowBit;
    
    if (len==1)   //余数为0，作为递归的结束条件 
       return num;
    else{
       lowBit=num%10;//保留最低位 
       restNum=num/10;//得到除去最低位后的余数 
       //递归调用，并形成逆置数 
       return lowBit*power(10,len-1) + reverse(restNum,len-1); 
    }
}
</code></pre>
<p>递归程序设计举例
练习4. 输入n个整数，求最大数。
15  30  34  10  89
设函数findMax(n)为读取n个数，求最大值
函数Maximum(x,y)为求两个数x和y的最大值
则findMax(n)递归定义：
findMax(1)=N1                                  当n=1
findMax(n)=Maximum(findMax(n-1),Nn) 当n&gt;1
求前n(n&gt;1)个数的最大值，分解为3步：
第1步：读取前n-1个数，求出最大值max；
第2步：读取第n个数num；
第3步：返回num和max之间的最大值</p>
<p>递归程序设计举例
// 读取n个数，求最大值</p>
<pre><code class="language-c">int findMax(int n) 
{
 	 int max;  //记录前n-1个数中的最大值 
 	 int num;  //读取的第n个值 
	 
	 if(n==1){  //求前1个数中的最大值
	        scanf(&quot;%d&quot;,&amp;num);
	        return num;
	 }
	 else{  
	     max=findMax(n-1); //第1步：读取前n-1个数，求出最大值max ；
	     scanf(&quot;%d&quot;,&amp;num); //第2步：读取第n个数num；	 
	     return num&gt;max?num:max;  /*第3步：计算并返回num和					               max之间的最大值*/
       }	    
}

findMax(4)   
   findMax(3)，

findMax(3)
   findMax(2)，

findMax(2)
  findMax(1)

findMax(1)   
      读取第1个数15
</code></pre>
<p>练习4. 输入n个整数，求最大数。
递归设计思路2：15  30  34  10  89
设函数findMax(n)为读取n个数，求最大值；
函数Maximum(x,y)为求两个数x和y的最大值；
则findMax(n)递归定义：
findMax(1)=N1                                  当n=1
findMax(n)=Maximum(N1,findMax(n-1)) 当n&gt;1
求前n(n&gt;1)个数的最大值，分解为3步：
第1步：读入第1个数num
第2步：调用递归函数，读取后续n-1个数，求最大数max
第3步：返回num和max中的最大值。</p>
<pre><code class="language-c">int findMax (int n)  // 读取n个数，求最大值
{ 
	int num, max;
	 
	if (n==1){
          scanf(&quot;%d&quot;,&amp;num);  /*第1步：读入一个数num */
	     return num;  /*若是最后一个数，则将其本身作为最大值并返回*/ 
	} 
	else{
         scanf(&quot;%d&quot;, &amp;num);  /*第1步：读入一个数num */
 	   max=findMax (n-1);    /*第2步：调用递归函数读取并求出后续n-1个 			                      数的最大值max*/ 
	   return num&gt;max?num:max; /*第3步：返回num和max中的最大值*/ 
     } 
}

findMax(4)
     读15， 调用findMax(3)

findMax(3) 
    读30，调用findMax(2) 

findMax(2)
   读34，调用findMax(1)

findMax(1)
   读10

</code></pre>
<p>例3：用函数fib求斐波那契数列的第n项。斐波那契数列为：0、1、1、2、3、…… 。函数fib定义如下：</p>
<pre><code class="language-c"># include &lt;stdio.h&gt; 
long fib (long);   
main()
{
     printf(“%ld”, fib(3));
     system(“pause”);
     return 0;
}
long fib (long n)
{
     if (n==1 || n==2) 
         return n-1;
     else
         return fib(n-2)+fib(n-1);
}
</code></pre>
<p>3.递归程序设计
每求一项数，需要递归调用2次该函数；计算斐波那契数列第30项的递归调用次数是2的30次方（大约10亿次！）
可见递归的思想特别符合人们的思维习惯，便于问题解决和编程实现。但递归的程序设计方法比较占用系统资源，效率也较低。
课下请改写fib函数，使用迭代算法实现
long fib(long n), 计算斐波那契数列第n项。</p>
<p>例4、汉诺塔问题</p>
<p>3、在A柱上有3只盘子，从小到大分别为1号，2号，3号
第(1)步将1号盘和2号盘视为一个整体；先将二者作为整体从A移至B，给3号盘创造能够一次移至C的机会。这一步记为	move( 2, A, C, B)
意思是将上面的2只盘子作为整体从A借助C移至B。
第(2)步将3号盘从A移至C，一次到位。记为
move 3 from A to C
第(3)步处于B上的作为一个整体的2只盘子，再移至C。这一步记为    	move( 2, B, A, C)
意思是将2只盘子作为整体从B借助A移至C。</p>
<p>4、从题目约束条件看，大盘上可以摞小盘，相反则不允许。在将1号和2号盘当整体从A移至B的过程中move(2, A, C, B)实际上是分解为以下三步
第1步：move 1 from A to C;
第2步：move 2 from A to B;
第3步：move 1 from C to B;</p>
<p>同样，3号盘一旦到了C，就要考虑如何实现将1号和2号盘当整体从B移至C的过程了。实际上move(2, B, A, C)也要分解为三步：
第1步：move 1 from B to A;
第2步：move 2 from B to C;
第3步：move 1 from A to C;</p>
<p>同理，将n个圆盘从A柱移到C柱move(n, A, B, C) 可分解为3步：
第1步.将A柱上从上往下数的（n－1）个圆盘移到B柱上，通过C柱为辅助。这是一个（n－1）个圆盘的问题：move(n-1,A,C,B)；
第2步. 将A柱上最后一个圆盘，直接移到C柱上；
第3步. 再将B柱上的（n－1）个圆盘移到C柱上，中间以A柱为辅助。这又是一个（n－1）个圆盘的问题:move(n-1,B,A,C)；</p>
<p>这显然是递归定义的，将问题分解成同类小问题。当解move(n-1, A, C, B)时，又可将其分解为3步：
第1步：将A柱上的n-2只盘子作为一个整体从A经B到C，move(n-2, A, B, C)；</p>
<p>第2步：第n-1号盘子从A直接移至B；
第3步：再将C柱上的n-2只盘子作为一个整体从C经A移至B，move(n-2, C, A, B)；</p>
<p>移动n个盘子的问题被简化成移动n－1个盘子的问题；
移动n-1个盘子的问题又被简化成移动n-2个盘子问题 ……
该过程反复进行，直到只剩下1个盘子时再将其移动。移动1个盘子的简单操作就是终止条件。</p>
<pre><code class="language-c">void move(int n, int from, int med, int to)
{
     if (n==1)
            printf(&quot;%d--&gt;%d \n&quot;, from, to);
     else{
             move(n-1, from, to, med);
     	 printf(&quot;%d--&gt;%d \n&quot;, from, to);
     	 move(n-1, med, from, to);
     }
}
#include&lt;stdio.h&gt;
void move(int n,int a,int b,int c);
main()
{
    int num；
    printf(&quot;the number of plate is:&quot;);
    scanf(&quot;%d&quot;,&amp;num);
    move(num, 1, 2, 3);
    system(“pause”);
    return 0;
 }
</code></pre>
<p>移动3个盘子的递归调用过程见《计算机导论与程序设计基础》261页
注意分析：
为何调用能正确返回
为何每次调用访问的是正确的函数运行空间
移动三个盘子的运行结果
the number of plate is:3
1&ndash;&gt;3
1&ndash;&gt;2
3&ndash;&gt;2
1&ndash;&gt;3
2&ndash;&gt;1
2&ndash;&gt;3
1&ndash;&gt;3
递归程序设计举例</p>
<p>练习5.  输入任意个整数，以-1结束，求最大数。</p>
<p>递归设计思路：
第一步：读入一个数num ;
第二步：调用递归函数求出剩下要读入的数的	        最大值max;
第三步：求出num和max中的最大值并返回，<br>
此值即为输入的所有数的最大值。</p>
<pre><code class="language-c">int findMax () 
{
    int num, max;
    scanf (&quot;%d&quot;, &amp;num);   //读入一个数num  
    if (num = = -1)
       return ?   ; //此处怎么写？
     else {
	   max = findMax();  //求出剩下要读入的数的最大值max
	   return(num&gt;max?num:max); //返回num和max中的最大值
      }	
}
findMax()
[20,-15,-1]
[20,-15,-1]
</code></pre>
<p>解决方法：将本次递归调用读入的数作为参数传到下一次递归调用中
函数接口：int findMax(int preNum)
函数功能：求preNum和后续读入的数的最大值</p>
<p>递归程序设计举例</p>
<pre><code class="language-c">int findMax (int preNum)  //参数为上一层读入的数 
{
    int max, curr_num; //当前最大值，当前层读入的数 
    scanf(&quot;%d&quot;, &amp; curr_num);
    if (curr_num ==-1)     //如果是结束标志 
         return  preNum ；
   else {
       //递归调用，得到后续数列中最大值 
        max=findMax (curr_num);
       //比较确定当前的最大值 
        return (preNum &gt; max? preNum :max); 
    }
}
</code></pre>
<p>[10, 20, -15, -1]</p>
<p>总结-1
递归的定义：
递归（Recursion），在数学与计算机科学中，是指在函数定义中使用函数自身的方法。
英文的Recursion从词源上分析只是“re-  (again)” + “curs- （come, happen）” 也就是重复发生，再次重现的意思。
而对应的中文翻译表达了：“递＋归”。这正是递归的核心思想。
总结-2
递归算法设计步骤:
设计问题最简单时候的终止条件和对应操作，即递归边界条件。
对所求解的问题，考虑如何拆分成与原问题性质相同但规模小一级的子问题，即书写递归定义。
根据以上两个步骤，正确地设计递归函数的参数。</p>
<p>总结-3
用递归定义描述曾经的算法：
例1、求n个数最大值的数学方法（递归）
Max(N1)=N1     		              (n=1，边界条件)
Max(Nn , Nn-1 ,…,N2,N1)
＝Max(Nn ,Max(Nn-1 ,…,N2,N1))   (n&gt;1，递归定义)</p>
<p>例2、求n个数的和的数学方法（递归）
sum(N1)=N1   				(n=1，边界条件)
sum(Nn , Nn-1 ,…,N2,N1)
＝sum(Nn ,sum(Nn-1 ,…,N2,N1))	(n&gt;1，递归定义)</p>

</main>

  <footer>
  <script defer src="//yihui.org/js/math-code.js"></script>
<script defer src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script defer src="//yihui.org/js/center-img.js"></script>

  
  <hr/>
  © <a href="https://github.com/Topology2333">Topology2333</a> 2022 &ndash; 2022 | <a href="https://github.com/Topology2333">Github</a> | <a href="https://twitter.com/VFriedrich8">Twitter</a>
  
  </footer>
  </body>
</html>

